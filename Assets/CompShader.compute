// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float4> _Points;

#define thread_group_size_x 1
#define thread_group_size_y 1



[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	int idx = id.x + id.y * 512; //thread_group_size_x * 32;
	//float spacing = 1.0;
	
	float2 pos1 = float2(-40.0, 0.0);
	float2 pos2 = float2(-10.0, 20.0);
	float2 pos3 = float2(20.0, -20.0);
	float2 pos4 = float2(40.0, 0.0);

	float2 position = _Points[idx].xy;
	float2 velocity = _Points[idx].zw;

	float distance1 = distance(pos1, position);
	float distance2 = distance(pos2, position);
	float distance3 = distance(pos3, position);
	float distance4 = distance(pos4, position);

	float2 deltaDir1 = float2(0.0, 0.0);//-normalize(pos1 - position) / pow(distance1, 1.5);
	float2 deltaDir2 = float2(0.0, 0.0);//-normalize(pos2 - position) / pow(distance2, 1.5);
	float2 deltaDir3 = normalize(pos3 - position) / pow(distance3, 1.9);
	float2 deltaDir4 = normalize(pos4 - position) / pow(distance4, 1.9);

	float damping = 0.9995;
	float2 velocityNew = velocity + (deltaDir1 + deltaDir2 + deltaDir3 + deltaDir4);
	velocityNew *= damping;

	float len = length(velocityNew);
	if (len > 1.0) {
		float2 dir = normalize(velocityNew);
		velocityNew = velocityNew*0.5;//dir*1.5;
	}

	if (len > 3.0) {
		float2 dir = normalize(velocityNew);
		velocityNew = dir*3.0;
	}

	_Points[idx].xy = position + velocityNew*1.0;
	_Points[idx].zw = velocityNew;

	//float3 pos = float3(id.x*spacing, id.y*spacing, id.z*spacing);

	//_Points[idx] = _Points[idx] + 0.01;
}
