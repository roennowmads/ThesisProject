//--------------------------------------------------------------------------------------
// File: ComputeShaderSort11.hlsl
//
// This file contains the compute shaders to perform GPU sorting using DirectX 11.
// 
// Copyright (c) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------

#pragma kernel BitonicSort
#pragma kernel MatrixTranspose

#include "UnityCG.cginc"

//--------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------

#define BITONIC_BLOCK_SIZE 512
#define TRANSPOSE_BLOCK_SIZE 32

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
cbuffer CB
{
    uint g_iLevel;
    uint g_iLevelMask;
    uint g_iWidth;
    uint g_iHeight;
};

cbuffer modelMatrix
{
	float4 row0;
	float4 row1;
	float4 row2;
	float4 row3;
};

cbuffer viewMatrix
{
	float4 rowView0;
	float4 rowView1;
	float4 rowView2;
	float4 rowView3;
};

struct indexDepth {
	uint indexAndColor;
	float depth;
};

//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
//StructuredBuffer<uint> Input : register( t0 );
//RWStructuredBuffer<uint> Data : register( u0 );

StructuredBuffer<uint> Input : register(t0);
RWStructuredBuffer<uint> Data : register(u0);


//StructuredBuffer<float3> _Points;
StructuredBuffer<float3> _Points;

//StructuredBuffer<uint> _IndicesValues;
//RWStructuredBuffer<uint> _IndicesValuesOut;

//float4x4 model;
float4 trans;
float3 camPos;

//--------------------------------------------------------------------------------------
// Bitonic Sort Compute Shader
//--------------------------------------------------------------------------------------
groupshared indexDepth shared_data[BITONIC_BLOCK_SIZE];
//groupshared uint shared_data[BITONIC_BLOCK_SIZE];

[numthreads(BITONIC_BLOCK_SIZE, 1, 1)]
void BitonicSort( uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID,  uint3 GTid : SV_GroupThreadID,  uint GI : SV_GroupIndex )
{
    // Load shared data
	uint indexAndColor = Data.Load(DTid.x);
	//uint index = value;//value / 256;//(value >> 8);
	/*shared_data[GI].index = index;*/

	matrix model = matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	model[0] = row0;
	model[1] = row1;
	model[2] = row2;
	model[3] = row3;

	matrix view = matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	view[0] = rowView0;
	view[1] = rowView1;
	view[2] = rowView2;
	view[3] = rowView3;

	//matrix a = matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	//float3 b = float3(0, 0, 0);

	//float4 vertexPos = float4(_Points[index], 1.0);
	//float depth = vertexPos.x;

	//float4 vertexPos = mul(model, -_Points[index]);
	//vertexPos += trans;
	//vertexPos = UnityWorldToClipPos(vertexPos.xyz);
	
	//float4 vertexPos = mul(UNITY_MATRIX_MV, _Points[index]);
	//float4 vertexPos = float4(_Points[index], 1.0);//UnityObjectToClipPos(_Points[index]);

	//float depth = length(_Points[index]);//vertexPos.z;

	//float4 transVert = mul(model, -_Points[indexAndColor >> 8]);

	//transVert += trans;
	//o.vertex = UnityWorldToClipPos(-_Points[index]);

	//transVert = UnityObjectToClipPos(transVert.xyz);


	float4 transVert = mul(model, float4(-_Points[indexAndColor >> 8], 1.0));
	transVert += trans;
	//transVert = mul(view, transVert);


	//transVert = mul(UNITY_MATRIX_VP, transVert);

	//float3 transVert = -_Points[indexAndColor >> 8];//mul(UNITY_MATRIX_MVP, float4(-_Points[indexAndColor >> 8], 1.0));

	shared_data[GI].indexAndColor = indexAndColor;
	shared_data[GI].depth = -distance(camPos, /*-_Points[indexAndColor >> 8]*/transVert.xyz);//float(DTid.x);//_Points[index].z;//;//depth;

	//shared_data[GI].depth = _Points[index];

	//shared_data[GI] = Data[DTid.x];

    GroupMemoryBarrierWithGroupSync();
    
    // Sort the shared data
    for (uint j = g_iLevel >> 1 ; j > 0 ; j >>= 1)
    {
		indexDepth result;
		if ((shared_data[GI & ~j].depth <= shared_data[GI | j].depth) == (bool)(g_iLevelMask & DTid.x)) {
			result = shared_data[GI ^ j];
		}
		else {
			result = shared_data[GI];
		}

		//uint result = ((shared_data[GI & ~j] <= shared_data[GI | j]) == (bool)(g_iLevelMask & DTid.x)) ? shared_data[GI ^ j] : shared_data[GI];
        GroupMemoryBarrierWithGroupSync();
        shared_data[GI] = result;
        GroupMemoryBarrierWithGroupSync();
    }
    
    // Store shared data
	//Data[DTid.x] = shared_data[GI];
    Data[DTid.x] = shared_data[GI].indexAndColor;
}

//--------------------------------------------------------------------------------------
// Matrix Transpose Compute Shader
//--------------------------------------------------------------------------------------
groupshared uint transpose_shared_data[TRANSPOSE_BLOCK_SIZE * TRANSPOSE_BLOCK_SIZE];
//groupshared float transpose_shared_data[TRANSPOSE_BLOCK_SIZE * TRANSPOSE_BLOCK_SIZE];

[numthreads(TRANSPOSE_BLOCK_SIZE, TRANSPOSE_BLOCK_SIZE, 1)]
void MatrixTranspose( uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex )
{
    transpose_shared_data[GI] = Input[DTid.y * g_iWidth + DTid.x];
    GroupMemoryBarrierWithGroupSync();
    uint2 XY = DTid.yx - GTid.yx + GTid.xy;
    Data[XY.y * g_iHeight + XY.x] = transpose_shared_data[GTid.x * TRANSPOSE_BLOCK_SIZE + GTid.y];
}
