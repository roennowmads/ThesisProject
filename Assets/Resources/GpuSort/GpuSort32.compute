//--------------------------------------------------------------------------------------
// File: ComputeShaderSort11.hlsl
//
// This file contains the compute shaders to perform GPU sorting using DirectX 11.
// 
// Copyright (c) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------

#pragma kernel BitonicSort
#pragma kernel MatrixTranspose

//#include "UnityCG.cginc"

//--------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------

#define BITONIC_BLOCK_SIZE 128//256//512
#define TRANSPOSE_BLOCK_SIZE 16//16//32

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
cbuffer CB
{
    uint g_iLevel;
    uint g_iLevelMask;
    uint g_iWidth;
    uint g_iHeight;
};

struct indexDepth {
	uint indexAndColor;
	float depth;
};

//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
StructuredBuffer<uint> Input /*: register(t0)*/;
RWStructuredBuffer<uint> Data /*: register(u0)*/;

StructuredBuffer<float3> _Points;

float4x4 model;
float3 camPos;

//--------------------------------------------------------------------------------------
// Bitonic Sort Compute Shader
//--------------------------------------------------------------------------------------
groupshared indexDepth shared_data[BITONIC_BLOCK_SIZE];

[numthreads(BITONIC_BLOCK_SIZE, 1, 1)]
void BitonicSort( uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID,  uint3 GTid : SV_GroupThreadID,  uint GI : SV_GroupIndex )
{
    // Load shared data
	uint indexAndColor = Data[DTid.x];
	float4 transVert = mul(model, float4(-_Points[indexAndColor >> 8], 1.0));

	shared_data[GI].indexAndColor = indexAndColor;
	//shared_data[GI].depth = -distance(camPos, transVert.xyz);
	shared_data[GI].depth = dot(camPos, transVert.xyz);

    GroupMemoryBarrierWithGroupSync();
    
    // Sort the shared data
    for (uint j = g_iLevel >> 1 ; j > 0 ; j >>= 1)
    {
		bool Test = (shared_data[GI & ~j].depth <= shared_data[GI | j].depth) == (bool)(g_iLevelMask & DTid.x);
		indexDepth result = shared_data[GI ^ j];

		GroupMemoryBarrierWithGroupSync();

		//if ((shared_data[GI & ~j].depth <= shared_data[GI | j].depth) == (bool)(g_iLevelMask & DTid.x)) {
		if (Test) {
			shared_data[GI] = result;
		}
		//else {
		//	result = shared_data[GI];
		//}
        GroupMemoryBarrierWithGroupSync();
    }
    
    // Store shared data
    Data[DTid.x] = shared_data[GI].indexAndColor;
}



//--------------------------------------------------------------------------------------
// Matrix Transpose Compute Shader
//--------------------------------------------------------------------------------------
groupshared uint transpose_shared_data[TRANSPOSE_BLOCK_SIZE * TRANSPOSE_BLOCK_SIZE];

[numthreads(TRANSPOSE_BLOCK_SIZE, TRANSPOSE_BLOCK_SIZE, 1)]
void MatrixTranspose( uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex )
{
	transpose_shared_data[GI] = Input[DTid.y * g_iWidth + DTid.x];
	GroupMemoryBarrierWithGroupSync();
	uint2 XY = DTid.yx - GTid.yx + GTid.xy;
	Data[XY.y * g_iHeight + XY.x] = transpose_shared_data[GTid.x * TRANSPOSE_BLOCK_SIZE + GTid.y];
}


