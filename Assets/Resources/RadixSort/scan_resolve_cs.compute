GLSLPROGRAM

	#pragma kernel scanResolve

	#version 310 es

	/*
	 * This proprietary software may be used only as
	 * authorised by a licensing agreement from ARM Limited
	 * (C) COPYRIGHT 2014-2015 ARM Limited
	 *     ALL RIGHTS RESERVED
	 * The entire notice above must be reproduced on all authorised
	 * copies and copies may only be made to the extent permitted
	 * by a licensing agreement from ARM Limited.
	 */

	/*
	 * Take a scan array which has been scanned per-block and sum array (inclusive scan for per-block results)
	 * and resolve the result to get a complete inclusive scan result.
	 * Needed if we need to do scan in multiple stages.
	 */

	layout(local_size_x = 32) in; // We work on 4 items at once, so this value should be BLOCK_SIZE / 4.
	struct _Uint4_type {
		uint[4] value;
	};

	layout(binding = 0, std430) readonly buffer Data
	{
		_Uint4_type buf[];
	};

	layout(binding = 1, std430) readonly buffer BlockSumData
	{
		_Uint4_type blocksum[];
	};

	layout(binding = 2, std430) writeonly buffer OutData
	{
		_Uint4_type outbuf[];
	};

	void main()
	{
		uint ident = gl_GlobalInvocationID.x;
		uint wg_ident = gl_WorkGroupID.x;

		uvec4 miniblock0;
		uvec4 miniblock1;
		uvec4 miniblock2;
		uvec4 miniblock3;

		miniblock0.x = buf[4u * ident + 0u].value[0];
		miniblock0.y = buf[4u * ident + 0u].value[1];
		miniblock0.z = buf[4u * ident + 0u].value[2];
		miniblock0.w = buf[4u * ident + 0u].value[3];

		miniblock1.x = buf[4u * ident + 1u].value[0];
		miniblock1.y = buf[4u * ident + 1u].value[1];
		miniblock1.z = buf[4u * ident + 1u].value[2];
		miniblock1.w = buf[4u * ident + 1u].value[3];

		miniblock2.x = buf[4u * ident + 2u].value[0];
		miniblock2.y = buf[4u * ident + 2u].value[1];
		miniblock2.z = buf[4u * ident + 2u].value[2];
		miniblock2.w = buf[4u * ident + 2u].value[3];

		miniblock3.x = buf[4u * ident + 3u].value[0];
		miniblock3.y = buf[4u * ident + 3u].value[1];
		miniblock3.z = buf[4u * ident + 3u].value[2];
		miniblock3.w = buf[4u * ident + 3u].value[3];


		if (wg_ident != 0u) {
			uvec4 prev_sum;
			prev_sum.x = blocksum[wg_ident - 1u].value[0];
			prev_sum.y = blocksum[wg_ident - 1u].value[1];
			prev_sum.z = blocksum[wg_ident - 1u].value[2];
			prev_sum.w = blocksum[wg_ident - 1u].value[3];


			miniblock0 += prev_sum;
			miniblock1 += prev_sum;
			miniblock2 += prev_sum;
			miniblock3 += prev_sum;
		}

		outbuf[4u * ident + 0u].value[0] = miniblock0.x;
		outbuf[4u * ident + 0u].value[1] = miniblock0.y;
		outbuf[4u * ident + 0u].value[2] = miniblock0.z;
		outbuf[4u * ident + 0u].value[3] = miniblock0.w;

		outbuf[4u * ident + 1u].value[0] = miniblock1.x;
		outbuf[4u * ident + 1u].value[1] = miniblock1.y;
		outbuf[4u * ident + 1u].value[2] = miniblock1.z;
		outbuf[4u * ident + 1u].value[3] = miniblock1.w;

		outbuf[4u * ident + 2u].value[0] = miniblock2.x;
		outbuf[4u * ident + 2u].value[1] = miniblock2.y;
		outbuf[4u * ident + 2u].value[2] = miniblock2.z;
		outbuf[4u * ident + 2u].value[3] = miniblock2.w;

		outbuf[4u * ident + 3u].value[0] = miniblock3.x;
		outbuf[4u * ident + 3u].value[1] = miniblock3.y;
		outbuf[4u * ident + 3u].value[2] = miniblock3.z;
		outbuf[4u * ident + 3u].value[3] = miniblock3.w;
	}

ENDGLSL